/**---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  *	Union - Find : 상호 배타적 집합 

  * Union : 두 원소의 집합을 하나로 합치는 함수 
  * Find : 특정 원소가 포함된 집합을 찾는 함수
		   
  * 초기 각 원소의 집합은 각 원소의 집합으로 선언  [각 배열의 인덱스가 해당 원소를 의미하며 배열의 데이터가 집합을 의미] 	   
		=> 일반적인 방식을 이용하면 pow(N,2) 시간복잡도가 발생하므로 이를 경로압축 및 가중법칙을 이용 [트리개념 사용] 하여 시간복잡도를 logN 이하로 줄임		
		
  * 경로 압축 : 각 원소들이 동일한 집합에 속하지만 트리구조로 형성되어있는 경우 [1 이라는 집합에 4 와 5 가 존재하지만 트리구조로 5 는 4의 하위 노드일 때 4를 찾기 위해서는 2번 탐색해야 함] 이를 곧바로 집합에 속하게하는 방법 	
  * 가중 법칙 : 두 집합을 하나로 합칠 때 트리의 깊이가 더 깊은 집합이 부모 , 더 얕은 집합이 자식이 되어 탐색시간을 줄이는 방법 [초기 가중치는 모두 1] 
  *---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void General_Union(int x , int y)
{
	int X , Y;
	X = General_Find(x);
	Y = General_Find(y);
	
	if(X == Y)
		return;
	else
		Set[X] = Y; // Set[Y] = X;
}

int General_Find(int x)
{
	if(x == Set[x])
		return x;
	else
		return General_Find(Set[x]);
}

void Upgrade_Union(int x , int y)
{
	int X , Y;
	
	X = Upgrade_Find(x);
	Y = Upgrade_Find(y);
	
	if(X == Y)
		return;
	else
	{
		if(rank[X] < rank[Y])
		{
			Set[X] = Y;
			rank[Y] += rank[X];
		}
		else
		{
			Set[Y] = X;
			rank[X] += rank[Y];		
		}
	}
}

int Upgrade_Find(int x)
{
	if(x == Set[x])
		return x;
	else
	{
		int temp = Find(Set[x]);
		Set[x] = temp;
		return temp;
	}
}
