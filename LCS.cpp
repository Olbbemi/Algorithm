/**------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  * LCS(Longest Common Subsequence) : 두개 이상의 문자열에서 불연속적인 공통 문자열 중 가장 긴 문자열을 찾는 알고리즘   

		A[], B[] : 문자열을 저장한 배열 
		D[] : 다이나믹을 이용하여 LCS 를 구할 배열
	
		- i == 0 || j == 0 : D[i][j] = 0;
		- A[i] == B[j] : D[i][j] = D[i - 1][j - 1] + 1
		- A[i] != B[j] : D[i][j] = max(D[i - 1][j] , D[i][j - 1])

  * 최장 문자열 역추적 : LCS 알고리즘으로 구한 배열 정보를 이용하여 문자열을 역추적 (역으로 추적하므로 문자열을 구한 뒤 스택 등을 이용하여 한번 더 뒤집어야 함)

		- A[] == B[] : Push(A[]) , i-- , j--
		- A[] != B[] : j-- ( D[i][j-1] > D[i-1][j] ) , i-- ( D[i][j-1] < D[i-1][j] ) 

  *	LCS(Longest Common Substring) : 두개 이상의 문자열에서 연속적인 공통 문자열 중 가장 긴 문자열을 찾는 알고리즘
	
		A[] , B[] : 문자열을 저장한 배열 
		D[] : 다이나믹을 이용하여 LCS 를 구할 배열
	
		- i == 0 || j == 0 : D[i][j] = 0;
		- A[i] == B[j] : D[i][j] = D[i - 1][j - 1] + 1
		- A[i] != B[j] : D[i][j] = 0
		
  *	최장 문자열 역추적 : LCS 알고리즘으로 구한 배열 정보에서 가장 큰 데이터 값의 위치를 찾은 후 문자열을 역추적 (역으로 추적하므로 문자열을 구한 뒤 스택 등을 이용하여 한번 더 뒤집어야 함)
		
		A[] == B[] : Push(A[]) , i-- , j--
  *------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

// LCS (Longest Common Subsequence)
for(i = 1; i <= N; i++)
{
	for(j = 1; j <= M; j++)
	{
		if(A[i] == A[j])
			D[i][j] = D[i - 1][j - 1] + 1;
		else
			D[i][j] = max(D[i - 1][j] , D[i][j - 1]);
	}
}

// Back Tracking
Asize = A.size();	
Bsize = B.size();

while(Asize > 0 && Bsize > 0)
{
	if(A[Asize - 1] == B[Bsize - 1])
	{
		Push(A[Asize - 1]);
		Asize--;	
		Bsize--;	
	}	
	else
	{
		if(D[Asize][Bsize - 1] > D[Asize - 1][Bsize])
			Bsize--;
		else
			Asize--;
	}
	
	while(Top != NULL)
		Pop();
}

// LCS (Longest Common Substring)
for(i = 1; i <= N; i++)
{
	for(j = 1; j <= M; j++)
	{
		if(A[i] == A[j])
			D[i][j] = D[i - 1][j - 1] + 1;
		else
			D[i][j] = 0;
	}
}